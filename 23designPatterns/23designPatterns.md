
## 一、23种模式 

* 创建模式 creational patterns

<div style="margin: 0 auto;padding:1rem;width: 36rem;text-align:center;">

   | 模式                  | 作用                                                                | 要点                 |
   | --------------------- | ------------------------------------------------------------------- | -------------------- |
   | [单例](./singleton)   | 全局就只有一个实列。                                                |
   | 工厂方法              | **产品是一大类**；不同工厂按需生产特定产品。                        |
   | [抽象工厂](./factory) | **产品是多种类**；不同工厂按需生产特定产品。                        | 注重各个类型产品创建 |
   | [ 建造者 ](./builder) | 产品由多部件组成；产品部件（builder）与部件组装过程（Director）解耦 | 注重复杂产品的组装   |
   | 原型模式              | 需要频繁new的对象，可以通过拷贝创建。                               |
</div>


* 结构型模式

<div style="margin: 0 auto;padding:1rem;width: 40rem;">

   | 模式                      | 作用                                                                                   | 要点                                                                                                                |
   | ------------------------- | -------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------- |
   | [ 适配器 ](./adaptor)     | 类与类之间的兼容转换                                                                   | 类适配: **继承**dest类提供src方法；<br> 对象适配: **聚合**dest类提供src方法；<br>接口适配: 不想实现接口中所有的方法 |
   | [ 桥接 ](./bridge)        | 抽象（使用方法）与实现（具体实物）的分离                                               | 抽象组合实物形成一个产品                                                                                            |
   | [享元模式](./flyweight/)  | 不变部分（内部）与变化部分（外部）分离；不变部分会进行全局共享且唯一；外部传入内部使用 | 外部 + 内部才视为产品                                                                                               |
   | [ 装饰模式 ](./decorator) | 将修饰与主体分离；主体可以被修饰无限包裹；靠递归进行输出。                             | **可用于叠加状态，计算总攻击力的场景。**                                                                            |
   | [组合](./composite)       | 对层级结构进行管理                                                                     |                                                                                                                     |
   | 门面模式                  | 对一系列子系统的复杂调用进行封装，客户不关心子类具体实现                               |
   | 代理                      | 通过代理类间接访问目标                                                                 | 静态代理：类似适配器 <br>JDK代理：目标有接口，利用反射实现 <br> Cglib代理：目标无接口                               |

</div>

* 行为模式

<div style="margin: 0 auto;padding:1rem;width: 38rem;">

   | 模式                    | 作用                                                 | 要点                                                         |
   | ----------------------- | ---------------------------------------------------- | ------------------------------------------------------------ |
   | 模板方法                | 抽象类提供了算法的骨架模板；变化细节由子类实现       | 钩子方法                                                     |
   | [ 命令模式 ](./command) | 命令产生与命令执行进行了分离                         | 能够撤销命令 <br> 命令被封装成对象                           |
   | [ 访问者 ](./visitor)   | 对数据的操作（访问方式）与数据结构（元素）进行分离   |
   | 迭代器                  | 将数据存放与遍历进行分离，方便外部对数据的遍历       | 使用迭代器，不同数据结构，对外的遍历方式都一样               |
   | 观察者                  | 发布（一）-订阅（多）                                |                                                              |
   | [中介](./mediator)      | 子系统之间的交流全部通过中介实现；子系统之间不交流   | 一个传递信息的服务器                                         |
   | 备忘录                  | 对类的数据进行存档；通过一个Manager对存档进行管理    |                                                              |
   | 解释器                  | 对文本语法进行解释                                   |                                                              |
   | 状态                    | 对于复杂的状态切换，代替if-else                      | 一个对象有不同状态；不同的状态，行为方式（行为是一样）会不同 |
   | 策略                    | 聚合多种属性；一类属性一个接口；一个对象聚合多种属性 |                                                              |
   | 职责链                  | 分等级处理请求；自己处理不了，就给下一级处理         |                                                              |

</div>

	* 职责链


## 二、面向对象7大原则

* 开闭原则：对扩展开放，对修改关闭
* 里氏替换：继承时，最好不要 overwrite 父类的方法
* 依赖倒置：面向接口编程，降低耦合
* 单一职责：一个方法，一个功能
* 接口隔离：接口的定义不能多，尽量刚刚好，实际使用时，不用多实现
* 迪米特：只与直接朋友有关联：成员变量，方法参数，方法返回值的类
* 合成复用：优先组合，其次继承

## 三、类与类之间的关系

* 依赖 dependency：用到了对方；主要是成员变量，方法返回，方法传参，方法使用
* 继承 generalization
* 实现 realization
* 关联 association：类之间具有导航性，双向或者单向
* 聚合 aggregation：关联的特例，整体与部分的关系，可分开
* 组合 composite：关联的特例，整体与部分的关系，不可分开

## 附录

* [GOF 23](http://c.biancheng.net/design_pattern/)
